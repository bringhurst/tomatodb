/* Generated by the protocol buffer compiler.  DO NOT EDIT! */

/* Do not generate deprecated warnings for self */
#ifndef PROTOBUF_C_NO_DEPRECATED
#define PROTOBUF_C_NO_DEPRECATED
#endif

#include "client.pb-c.h"
void   haven__client__command__init
(Haven__Client__Command*         message)
{
    static Haven__Client__Command init_value = HVN__CLIENT__COMMAND__INIT;
    *message = init_value;
}
size_t haven__client__command__get_packed_size
(const Haven__Client__Command* message)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__client__command__descriptor);
    return protobuf_c_message_get_packed_size((const ProtobufCMessage*)(message));
}
size_t haven__client__command__pack
(const Haven__Client__Command* message,
 uint8_t*       out)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__client__command__descriptor);
    return protobuf_c_message_pack((const ProtobufCMessage*)message, out);
}
size_t haven__client__command__pack_to_buffer
(const Haven__Client__Command* message,
 ProtobufCBuffer* buffer)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__client__command__descriptor);
    return protobuf_c_message_pack_to_buffer((const ProtobufCMessage*)message, buffer);
}
Haven__Client__Command*
haven__client__command__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data)
{
    return (Haven__Client__Command*)
           protobuf_c_message_unpack(&haven__client__command__descriptor,
                                     allocator, len, data);
}
void   haven__client__command__free_unpacked
(Haven__Client__Command* message,
 ProtobufCAllocator* allocator)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__client__command__descriptor);
    protobuf_c_message_free_unpacked((ProtobufCMessage*)message, allocator);
}
void   haven__client__command_result__init
(Haven__Client__CommandResult*         message)
{
    static Haven__Client__CommandResult init_value = HVN__CLIENT__COMMAND_RESULT__INIT;
    *message = init_value;
}
size_t haven__client__command_result__get_packed_size
(const Haven__Client__CommandResult* message)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__client__command_result__descriptor);
    return protobuf_c_message_get_packed_size((const ProtobufCMessage*)(message));
}
size_t haven__client__command_result__pack
(const Haven__Client__CommandResult* message,
 uint8_t*       out)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__client__command_result__descriptor);
    return protobuf_c_message_pack((const ProtobufCMessage*)message, out);
}
size_t haven__client__command_result__pack_to_buffer
(const Haven__Client__CommandResult* message,
 ProtobufCBuffer* buffer)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__client__command_result__descriptor);
    return protobuf_c_message_pack_to_buffer((const ProtobufCMessage*)message, buffer);
}
Haven__Client__CommandResult*
haven__client__command_result__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data)
{
    return (Haven__Client__CommandResult*)
           protobuf_c_message_unpack(&haven__client__command_result__descriptor,
                                     allocator, len, data);
}
void   haven__client__command_result__free_unpacked
(Haven__Client__CommandResult* message,
 ProtobufCAllocator* allocator)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__client__command_result__descriptor);
    protobuf_c_message_free_unpacked((ProtobufCMessage*)message, allocator);
}
void   haven__client__heartbeat_update__init
(Haven__Client__HeartbeatUpdate*         message)
{
    static Haven__Client__HeartbeatUpdate init_value = HVN__CLIENT__HEARTBEAT_UPDATE__INIT;
    *message = init_value;
}
size_t haven__client__heartbeat_update__get_packed_size
(const Haven__Client__HeartbeatUpdate* message)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__client__heartbeat_update__descriptor);
    return protobuf_c_message_get_packed_size((const ProtobufCMessage*)(message));
}
size_t haven__client__heartbeat_update__pack
(const Haven__Client__HeartbeatUpdate* message,
 uint8_t*       out)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__client__heartbeat_update__descriptor);
    return protobuf_c_message_pack((const ProtobufCMessage*)message, out);
}
size_t haven__client__heartbeat_update__pack_to_buffer
(const Haven__Client__HeartbeatUpdate* message,
 ProtobufCBuffer* buffer)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__client__heartbeat_update__descriptor);
    return protobuf_c_message_pack_to_buffer((const ProtobufCMessage*)message, buffer);
}
Haven__Client__HeartbeatUpdate*
haven__client__heartbeat_update__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data)
{
    return (Haven__Client__HeartbeatUpdate*)
           protobuf_c_message_unpack(&haven__client__heartbeat_update__descriptor,
                                     allocator, len, data);
}
void   haven__client__heartbeat_update__free_unpacked
(Haven__Client__HeartbeatUpdate* message,
 ProtobufCAllocator* allocator)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__client__heartbeat_update__descriptor);
    protobuf_c_message_free_unpacked((ProtobufCMessage*)message, allocator);
}
void   haven__client__heartbeat_result__init
(Haven__Client__HeartbeatResult*         message)
{
    static Haven__Client__HeartbeatResult init_value = HVN__CLIENT__HEARTBEAT_RESULT__INIT;
    *message = init_value;
}
size_t haven__client__heartbeat_result__get_packed_size
(const Haven__Client__HeartbeatResult* message)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__client__heartbeat_result__descriptor);
    return protobuf_c_message_get_packed_size((const ProtobufCMessage*)(message));
}
size_t haven__client__heartbeat_result__pack
(const Haven__Client__HeartbeatResult* message,
 uint8_t*       out)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__client__heartbeat_result__descriptor);
    return protobuf_c_message_pack((const ProtobufCMessage*)message, out);
}
size_t haven__client__heartbeat_result__pack_to_buffer
(const Haven__Client__HeartbeatResult* message,
 ProtobufCBuffer* buffer)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__client__heartbeat_result__descriptor);
    return protobuf_c_message_pack_to_buffer((const ProtobufCMessage*)message, buffer);
}
Haven__Client__HeartbeatResult*
haven__client__heartbeat_result__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data)
{
    return (Haven__Client__HeartbeatResult*)
           protobuf_c_message_unpack(&haven__client__heartbeat_result__descriptor,
                                     allocator, len, data);
}
void   haven__client__heartbeat_result__free_unpacked
(Haven__Client__HeartbeatResult* message,
 ProtobufCAllocator* allocator)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__client__heartbeat_result__descriptor);
    protobuf_c_message_free_unpacked((ProtobufCMessage*)message, allocator);
}
const ProtobufCEnumValue haven__client__command__concurrency_type__enum_values_by_number[2] = {
    { "READ_WRITE", "HVN__CLIENT__COMMAND__CONCURRENCY_TYPE__READ_WRITE", 1 },
    { "READ_ONLY", "HVN__CLIENT__COMMAND__CONCURRENCY_TYPE__READ_ONLY", 2 },
};
static const ProtobufCIntRange haven__client__command__concurrency_type__value_ranges[] = {
    {1, 0}, {0, 2}
};
const ProtobufCEnumValueIndex haven__client__command__concurrency_type__enum_values_by_name[2] = {
    { "READ_ONLY", 1 },
    { "READ_WRITE", 0 },
};
const ProtobufCEnumDescriptor haven__client__command__concurrency_type__descriptor = {
    PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC,
    "haven.client.command.concurrency_type",
    "concurrency_type",
    "Haven__Client__Command__ConcurrencyType",
    "haven.client",
    2,
    haven__client__command__concurrency_type__enum_values_by_number,
    2,
    haven__client__command__concurrency_type__enum_values_by_name,
    1,
    haven__client__command__concurrency_type__value_ranges,
    NULL, NULL, NULL, NULL /* reserved[1234] */
};
static const Haven__Client__Command__ConcurrencyType haven__client__command__type__default_value = HVN__CLIENT__COMMAND__CONCURRENCY_TYPE__READ_WRITE;
static const ProtobufCFieldDescriptor haven__client__command__field_descriptors[2] = {
    {
        "type",
        3,
        PROTOBUF_C_LABEL_REQUIRED,
        PROTOBUF_C_TYPE_ENUM,
        0,   /* quantifier_offset */
        PROTOBUF_C_OFFSETOF(Haven__Client__Command, type),
        &haven__client__command__concurrency_type__descriptor,
        &haven__client__command__type__default_value,
        0,            /* packed */
        0, NULL, NULL  /* reserved1,reserved2, etc */
    },
    {
        "command",
        4,
        PROTOBUF_C_LABEL_REQUIRED,
        PROTOBUF_C_TYPE_MESSAGE,
        0,   /* quantifier_offset */
        PROTOBUF_C_OFFSETOF(Haven__Client__Command, command),
        &haven__database__log_command__descriptor,
        NULL,
        0,            /* packed */
        0, NULL, NULL  /* reserved1,reserved2, etc */
    },
};
static const unsigned haven__client__command__field_indices_by_name[] = {
    1,   /* field[1] = command */
    0,   /* field[0] = type */
};
static const ProtobufCIntRange haven__client__command__number_ranges[1 + 1] = {
    { 3, 0 },
    { 0, 2 }
};
const ProtobufCMessageDescriptor haven__client__command__descriptor = {
    PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
    "haven.client.command",
    "Command",
    "Haven__Client__Command",
    "haven.client",
    sizeof(Haven__Client__Command),
    2,
    haven__client__command__field_descriptors,
    haven__client__command__field_indices_by_name,
    1,  haven__client__command__number_ranges,
    (ProtobufCMessageInit) haven__client__command__init,
    NULL, NULL, NULL  /* reserved[123] */
};
static const ProtobufCFieldDescriptor haven__client__command_result__field_descriptors[1] = {
    {
        "success",
        1,
        PROTOBUF_C_LABEL_REQUIRED,
        PROTOBUF_C_TYPE_BOOL,
        0,   /* quantifier_offset */
        PROTOBUF_C_OFFSETOF(Haven__Client__CommandResult, success),
        NULL,
        NULL,
        0,            /* packed */
        0, NULL, NULL  /* reserved1,reserved2, etc */
    },
};
static const unsigned haven__client__command_result__field_indices_by_name[] = {
    0,   /* field[0] = success */
};
static const ProtobufCIntRange haven__client__command_result__number_ranges[1 + 1] = {
    { 1, 0 },
    { 0, 1 }
};
const ProtobufCMessageDescriptor haven__client__command_result__descriptor = {
    PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
    "haven.client.command_result",
    "CommandResult",
    "Haven__Client__CommandResult",
    "haven.client",
    sizeof(Haven__Client__CommandResult),
    1,
    haven__client__command_result__field_descriptors,
    haven__client__command_result__field_indices_by_name,
    1,  haven__client__command_result__number_ranges,
    (ProtobufCMessageInit) haven__client__command_result__init,
    NULL, NULL, NULL  /* reserved[123] */
};
static const ProtobufCFieldDescriptor haven__client__heartbeat_update__field_descriptors[2] = {
    {
        "id",
        1,
        PROTOBUF_C_LABEL_REQUIRED,
        PROTOBUF_C_TYPE_INT64,
        0,   /* quantifier_offset */
        PROTOBUF_C_OFFSETOF(Haven__Client__HeartbeatUpdate, id),
        NULL,
        NULL,
        0,            /* packed */
        0, NULL, NULL  /* reserved1,reserved2, etc */
    },
    {
        "watched_keys",
        2,
        PROTOBUF_C_LABEL_REPEATED,
        PROTOBUF_C_TYPE_STRING,
        PROTOBUF_C_OFFSETOF(Haven__Client__HeartbeatUpdate, n_watched_keys),
        PROTOBUF_C_OFFSETOF(Haven__Client__HeartbeatUpdate, watched_keys),
        NULL,
        NULL,
        0,            /* packed */
        0, NULL, NULL  /* reserved1,reserved2, etc */
    },
};
static const unsigned haven__client__heartbeat_update__field_indices_by_name[] = {
    0,   /* field[0] = id */
    1,   /* field[1] = watched_keys */
};
static const ProtobufCIntRange haven__client__heartbeat_update__number_ranges[1 + 1] = {
    { 1, 0 },
    { 0, 2 }
};
const ProtobufCMessageDescriptor haven__client__heartbeat_update__descriptor = {
    PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
    "haven.client.heartbeat_update",
    "HeartbeatUpdate",
    "Haven__Client__HeartbeatUpdate",
    "haven.client",
    sizeof(Haven__Client__HeartbeatUpdate),
    2,
    haven__client__heartbeat_update__field_descriptors,
    haven__client__heartbeat_update__field_indices_by_name,
    1,  haven__client__heartbeat_update__number_ranges,
    (ProtobufCMessageInit) haven__client__heartbeat_update__init,
    NULL, NULL, NULL  /* reserved[123] */
};
static const ProtobufCFieldDescriptor haven__client__heartbeat_result__field_descriptors[4] = {
    {
        "timeout",
        1,
        PROTOBUF_C_LABEL_REQUIRED,
        PROTOBUF_C_TYPE_INT64,
        0,   /* quantifier_offset */
        PROTOBUF_C_OFFSETOF(Haven__Client__HeartbeatResult, timeout),
        NULL,
        NULL,
        0,            /* packed */
        0, NULL, NULL  /* reserved1,reserved2, etc */
    },
    {
        "last_log_index",
        2,
        PROTOBUF_C_LABEL_REQUIRED,
        PROTOBUF_C_TYPE_INT64,
        0,   /* quantifier_offset */
        PROTOBUF_C_OFFSETOF(Haven__Client__HeartbeatResult, last_log_index),
        NULL,
        NULL,
        0,            /* packed */
        0, NULL, NULL  /* reserved1,reserved2, etc */
    },
    {
        "last_log_term",
        3,
        PROTOBUF_C_LABEL_REQUIRED,
        PROTOBUF_C_TYPE_INT64,
        0,   /* quantifier_offset */
        PROTOBUF_C_OFFSETOF(Haven__Client__HeartbeatResult, last_log_term),
        NULL,
        NULL,
        0,            /* packed */
        0, NULL, NULL  /* reserved1,reserved2, etc */
    },
    {
        "updated_entries",
        4,
        PROTOBUF_C_LABEL_OPTIONAL,
        PROTOBUF_C_TYPE_MESSAGE,
        0,   /* quantifier_offset */
        PROTOBUF_C_OFFSETOF(Haven__Client__HeartbeatResult, updated_entries),
        &haven__database__append_entries__descriptor,
        NULL,
        0,            /* packed */
        0, NULL, NULL  /* reserved1,reserved2, etc */
    },
};
static const unsigned haven__client__heartbeat_result__field_indices_by_name[] = {
    1,   /* field[1] = last_log_index */
    2,   /* field[2] = last_log_term */
    0,   /* field[0] = timeout */
    3,   /* field[3] = updated_entries */
};
static const ProtobufCIntRange haven__client__heartbeat_result__number_ranges[1 + 1] = {
    { 1, 0 },
    { 0, 4 }
};
const ProtobufCMessageDescriptor haven__client__heartbeat_result__descriptor = {
    PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
    "haven.client.heartbeat_result",
    "HeartbeatResult",
    "Haven__Client__HeartbeatResult",
    "haven.client",
    sizeof(Haven__Client__HeartbeatResult),
    4,
    haven__client__heartbeat_result__field_descriptors,
    haven__client__heartbeat_result__field_indices_by_name,
    1,  haven__client__heartbeat_result__number_ranges,
    (ProtobufCMessageInit) haven__client__heartbeat_result__init,
    NULL, NULL, NULL  /* reserved[123] */
};
static const ProtobufCMethodDescriptor haven__client__client__method_descriptors[2] = {
    { "heartbeat", &haven__client__heartbeat_update__descriptor, &haven__client__heartbeat_result__descriptor },
    { "operation", &haven__client__command__descriptor, &haven__client__command_result__descriptor },
};
const unsigned haven__client__client__method_indices_by_name[] = {
    0,        /* heartbeat */
    1         /* operation */
};
const ProtobufCServiceDescriptor haven__client__client__descriptor = {
    PROTOBUF_C_SERVICE_DESCRIPTOR_MAGIC,
    "haven.client.client",
    "operation",
    "Haven__Client__Client",
    "haven.client",
    2,
    haven__client__client__method_descriptors,
    haven__client__client__method_indices_by_name
};
void haven__client__client__heartbeat(ProtobufCService* service,
                                      const Haven__Client__HeartbeatUpdate* input,
                                      Haven__Client__HeartbeatResult_Closure closure,
                                      void* closure_data)
{
    PROTOBUF_C_ASSERT(service->descriptor == &haven__client__client__descriptor);
    service->invoke(service, 0, (const ProtobufCMessage*) input, (ProtobufCClosure) closure, closure_data);
}
void haven__client__client__operation(ProtobufCService* service,
                                      const Haven__Client__Command* input,
                                      Haven__Client__CommandResult_Closure closure,
                                      void* closure_data)
{
    PROTOBUF_C_ASSERT(service->descriptor == &haven__client__client__descriptor);
    service->invoke(service, 1, (const ProtobufCMessage*) input, (ProtobufCClosure) closure, closure_data);
}
void haven__client__client__init(Haven__Client__Client_Service* service,
                                 Haven__Client__Client_ServiceDestroy destroy)
{
    protobuf_c_service_generated_init(&service->base,
                                      &haven__client__client__descriptor,
                                      (ProtobufCServiceDestroy) destroy);
}
