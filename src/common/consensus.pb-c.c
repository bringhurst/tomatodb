/* Generated by the protocol buffer compiler.  DO NOT EDIT! */

/* Do not generate deprecated warnings for self */
#ifndef PROTOBUF_C_NO_DEPRECATED
#define PROTOBUF_C_NO_DEPRECATED
#endif

#include "consensus.pb-c.h"
void   haven__consensus__vote__init
(Haven__Consensus__Vote*         message)
{
    static Haven__Consensus__Vote init_value = HAVEN__CONSENSUS__VOTE__INIT;
    *message = init_value;
}
size_t haven__consensus__vote__get_packed_size
(const Haven__Consensus__Vote* message)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__consensus__vote__descriptor);
    return protobuf_c_message_get_packed_size((const ProtobufCMessage*)(message));
}
size_t haven__consensus__vote__pack
(const Haven__Consensus__Vote* message,
 uint8_t*       out)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__consensus__vote__descriptor);
    return protobuf_c_message_pack((const ProtobufCMessage*)message, out);
}
size_t haven__consensus__vote__pack_to_buffer
(const Haven__Consensus__Vote* message,
 ProtobufCBuffer* buffer)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__consensus__vote__descriptor);
    return protobuf_c_message_pack_to_buffer((const ProtobufCMessage*)message, buffer);
}
Haven__Consensus__Vote*
haven__consensus__vote__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data)
{
    return (Haven__Consensus__Vote*)
           protobuf_c_message_unpack(&haven__consensus__vote__descriptor,
                                     allocator, len, data);
}
void   haven__consensus__vote__free_unpacked
(Haven__Consensus__Vote* message,
 ProtobufCAllocator* allocator)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__consensus__vote__descriptor);
    protobuf_c_message_free_unpacked((ProtobufCMessage*)message, allocator);
}
void   haven__consensus__consensus_result__init
(Haven__Consensus__ConsensusResult*         message)
{
    static Haven__Consensus__ConsensusResult init_value = HAVEN__CONSENSUS__CONSENSUS_RESULT__INIT;
    *message = init_value;
}
size_t haven__consensus__consensus_result__get_packed_size
(const Haven__Consensus__ConsensusResult* message)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__consensus__consensus_result__descriptor);
    return protobuf_c_message_get_packed_size((const ProtobufCMessage*)(message));
}
size_t haven__consensus__consensus_result__pack
(const Haven__Consensus__ConsensusResult* message,
 uint8_t*       out)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__consensus__consensus_result__descriptor);
    return protobuf_c_message_pack((const ProtobufCMessage*)message, out);
}
size_t haven__consensus__consensus_result__pack_to_buffer
(const Haven__Consensus__ConsensusResult* message,
 ProtobufCBuffer* buffer)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__consensus__consensus_result__descriptor);
    return protobuf_c_message_pack_to_buffer((const ProtobufCMessage*)message, buffer);
}
Haven__Consensus__ConsensusResult*
haven__consensus__consensus_result__unpack
(ProtobufCAllocator*  allocator,
 size_t               len,
 const uint8_t*       data)
{
    return (Haven__Consensus__ConsensusResult*)
           protobuf_c_message_unpack(&haven__consensus__consensus_result__descriptor,
                                     allocator, len, data);
}
void   haven__consensus__consensus_result__free_unpacked
(Haven__Consensus__ConsensusResult* message,
 ProtobufCAllocator* allocator)
{
    PROTOBUF_C_ASSERT(message->base.descriptor == &haven__consensus__consensus_result__descriptor);
    protobuf_c_message_free_unpacked((ProtobufCMessage*)message, allocator);
}
static const ProtobufCFieldDescriptor haven__consensus__vote__field_descriptors[4] = {
    {
        "candidate_term",
        1,
        PROTOBUF_C_LABEL_REQUIRED,
        PROTOBUF_C_TYPE_INT64,
        0,   /* quantifier_offset */
        PROTOBUF_C_OFFSETOF(Haven__Consensus__Vote, candidate_term),
        NULL,
        NULL,
        0,            /* packed */
        0, NULL, NULL  /* reserved1,reserved2, etc */
    },
    {
        "candidate_id",
        2,
        PROTOBUF_C_LABEL_REQUIRED,
        PROTOBUF_C_TYPE_INT64,
        0,   /* quantifier_offset */
        PROTOBUF_C_OFFSETOF(Haven__Consensus__Vote, candidate_id),
        NULL,
        NULL,
        0,            /* packed */
        0, NULL, NULL  /* reserved1,reserved2, etc */
    },
    {
        "last_log_index",
        3,
        PROTOBUF_C_LABEL_REQUIRED,
        PROTOBUF_C_TYPE_INT64,
        0,   /* quantifier_offset */
        PROTOBUF_C_OFFSETOF(Haven__Consensus__Vote, last_log_index),
        NULL,
        NULL,
        0,            /* packed */
        0, NULL, NULL  /* reserved1,reserved2, etc */
    },
    {
        "last_log_term",
        4,
        PROTOBUF_C_LABEL_REQUIRED,
        PROTOBUF_C_TYPE_INT64,
        0,   /* quantifier_offset */
        PROTOBUF_C_OFFSETOF(Haven__Consensus__Vote, last_log_term),
        NULL,
        NULL,
        0,            /* packed */
        0, NULL, NULL  /* reserved1,reserved2, etc */
    },
};
static const unsigned haven__consensus__vote__field_indices_by_name[] = {
    1,   /* field[1] = candidate_id */
    0,   /* field[0] = candidate_term */
    2,   /* field[2] = last_log_index */
    3,   /* field[3] = last_log_term */
};
static const ProtobufCIntRange haven__consensus__vote__number_ranges[1 + 1] = {
    { 1, 0 },
    { 0, 4 }
};
const ProtobufCMessageDescriptor haven__consensus__vote__descriptor = {
    PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
    "haven.consensus.vote",
    "Vote",
    "Haven__Consensus__Vote",
    "haven.consensus",
    sizeof(Haven__Consensus__Vote),
    4,
    haven__consensus__vote__field_descriptors,
    haven__consensus__vote__field_indices_by_name,
    1,  haven__consensus__vote__number_ranges,
    (ProtobufCMessageInit) haven__consensus__vote__init,
    NULL, NULL, NULL  /* reserved[123] */
};
static const ProtobufCFieldDescriptor haven__consensus__consensus_result__field_descriptors[2] = {
    {
        "term",
        1,
        PROTOBUF_C_LABEL_REQUIRED,
        PROTOBUF_C_TYPE_INT64,
        0,   /* quantifier_offset */
        PROTOBUF_C_OFFSETOF(Haven__Consensus__ConsensusResult, term),
        NULL,
        NULL,
        0,            /* packed */
        0, NULL, NULL  /* reserved1,reserved2, etc */
    },
    {
        "success",
        2,
        PROTOBUF_C_LABEL_REQUIRED,
        PROTOBUF_C_TYPE_BOOL,
        0,   /* quantifier_offset */
        PROTOBUF_C_OFFSETOF(Haven__Consensus__ConsensusResult, success),
        NULL,
        NULL,
        0,            /* packed */
        0, NULL, NULL  /* reserved1,reserved2, etc */
    },
};
static const unsigned haven__consensus__consensus_result__field_indices_by_name[] = {
    1,   /* field[1] = success */
    0,   /* field[0] = term */
};
static const ProtobufCIntRange haven__consensus__consensus_result__number_ranges[1 + 1] = {
    { 1, 0 },
    { 0, 2 }
};
const ProtobufCMessageDescriptor haven__consensus__consensus_result__descriptor = {
    PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
    "haven.consensus.consensus_result",
    "ConsensusResult",
    "Haven__Consensus__ConsensusResult",
    "haven.consensus",
    sizeof(Haven__Consensus__ConsensusResult),
    2,
    haven__consensus__consensus_result__field_descriptors,
    haven__consensus__consensus_result__field_indices_by_name,
    1,  haven__consensus__consensus_result__number_ranges,
    (ProtobufCMessageInit) haven__consensus__consensus_result__init,
    NULL, NULL, NULL  /* reserved[123] */
};
static const ProtobufCMethodDescriptor haven__consensus__consensus__method_descriptors[2] = {
    { "request_vote", &haven__consensus__vote__descriptor, &haven__consensus__consensus_result__descriptor },
    { "append_log_entries", &haven__database__append_entries__descriptor, &haven__consensus__consensus_result__descriptor },
};
const unsigned haven__consensus__consensus__method_indices_by_name[] = {
    1,        /* append_log_entries */
    0         /* request_vote */
};
const ProtobufCServiceDescriptor haven__consensus__consensus__descriptor = {
    PROTOBUF_C_SERVICE_DESCRIPTOR_MAGIC,
    "haven.consensus.consensus",
    "request_vote",
    "Haven__Consensus__Consensus",
    "haven.consensus",
    2,
    haven__consensus__consensus__method_descriptors,
    haven__consensus__consensus__method_indices_by_name
};
void haven__consensus__consensus__request_vote(ProtobufCService* service,
        const Haven__Consensus__Vote* input,
        Haven__Consensus__ConsensusResult_Closure closure,
        void* closure_data)
{
    PROTOBUF_C_ASSERT(service->descriptor == &haven__consensus__consensus__descriptor);
    service->invoke(service, 0, (const ProtobufCMessage*) input, (ProtobufCClosure) closure, closure_data);
}
void haven__consensus__consensus__append_log_entries(ProtobufCService* service,
        const Haven__Database__AppendEntries* input,
        Haven__Consensus__ConsensusResult_Closure closure,
        void* closure_data)
{
    PROTOBUF_C_ASSERT(service->descriptor == &haven__consensus__consensus__descriptor);
    service->invoke(service, 1, (const ProtobufCMessage*) input, (ProtobufCClosure) closure, closure_data);
}
void haven__consensus__consensus__init(Haven__Consensus__Consensus_Service* service,
                                       Haven__Consensus__Consensus_ServiceDestroy destroy)
{
    protobuf_c_service_generated_init(&service->base,
                                      &haven__consensus__consensus__descriptor,
                                      (ProtobufCServiceDestroy) destroy);
}
